# 要冲了啊 





q2  讲讲spring 的事务隔离机制

q3  aop晓得么 讲讲是什么？ 动态代理有哪几种实现方式

q4 ioc 是什么

q5 spring 一个bean 的注入流程

​	springbean的生命周期

​	springmvc的处理流程

### 0401

1 object 常见方法 

​	clone ,wait,notify,notifyall,hashcode,equals, finalize ,getclass,tostring

2 四种访问修饰符的区别？

​	private default protect public

​	类内 包内 不同包子类 所有包



## 1 基本面试题

**1 JDK 和JRE 的区别？**



jdk  java development kit 简称，java开发工具包，提供了java 开发环境和运行环境。

​			jre+

jre java运行环境，为java 提供了运行所需环境。 jvm+核心类库。

jre 主要包括核心类库和jvm，jdk包括jre 还有java源码的编译器javac ，以及调试和分析的工具。



**2 equals 和 ==的区别？**

 ==  对于基本类型 就是比较数值是否相同 

​		对于引用类型 比较 引用是否相同

equals  就是比较引用 

但是 string integer Math重写了equals方法 。



**3 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？重写equals方法时，为什么要重写hashcode方法？**

equals 和 hashCode 都是object中的默认方法，

```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

```java
public native int hashCode();
```

equals在不重写的情况下，就是判断基本类型的值，已经引用类型的引用，是否指向同一个内存地址。

 Object类源码中，hashCode()是一个native方法，哈希值的计算利用的是内存地址。 

 Java对象的eqauls方法和hashCode方法是这样规定的： 

 **1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。** 

 **2、如果两个对象的hashCode相同，它们并不一定相同** 

 如果一个类重写了equals方法但是没有重写hashCode方法，那么该类无法结合所有基于散列的集合（HashMap，HashSet）一起正常运作。 



4 **final 在 Java 中有什么作用？**

​	修饰类 不可以被继承

​	修饰方法 不可以被重修

​	修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。

**6.String 属于基础的数据类型吗？**

no

 bollean byte  1个字节

short char     2 个字节

 int float        4 个字节

 long double	8个字节

7. **Java 中操作字符串都有哪些类？它们之间有什么区别？**

String  StringBuffer  StringBuilder

string 声明的是不可变的对象，每次操作都会生成一个新的string 被final修饰 private final char value[];

stringbuffer/builder 可以对原有的对象基础上进行操作

  线程安全

stringbuffer 线程安全 多线程用

stringbuilder 线程不安全 单线程可以用效率高



**8 String str="i"与 String str=new String("i")一样吗？**

不一样   前者 在常量池中存放在常量池中

​		/ 常量池 分静态常量池和动态常量池

​				静态常量池 在class文件中  尚未加载到硬盘 存放常量(文本字符串和被final修饰的变量 符号引用 类的接口和全名 字段和方法的  名称 描述符等)

​				运行常量池 class文件中的常量池 经过类加载器加载class后 进入方法区中的 运行时常量池 ，全局共享，多个类共用。

 

后者 在 堆中存储

​			

**9 如何将字符串反转？****

1 使用 stringbuffer或stringbuilder中的reverse方法

```java
 public static String revv(String ss){
        StringBuilder s = new StringBuilder(ss);

        return s.reverse().toString();
    }
```

2 charat  for  stringbuffer.append.tostring

```java
 public static String revv(String ss){
        StringBuilder s = new StringBuilder();
        int i = ss.length();
        for (int t = i-1;t>=0;t--){
            char c = ss.charAt(t);
            System.out.println(c);
            s.append(c);
        }
        return s.toString();
    }
```

3用栈的方法

```java
  public static String revv(String ss){
        Stack<Character> stack  = new Stack<>();
        for (int i=0;i<ss.length();i++){
            stack.push(ss.charAt(i));
        }
        StringBuilder builder = new StringBuilder();
        while (!stack.empty()){
            builder.append(stack.pop());
        }
        return builder.toString();

    }
```



**10 .String 类的常用方法都有那些**

charat  

substring 截取字符串 

replace  替换字符串

equals	

length

indexof  字符或字符串第一次出现的位置

toLowerCase /toUpperCase 



**11 抽象类必须有抽象方法么？**

no  

但是抽象类中 抽象方法(abstract修饰 无实现) 子类必须实现

一个类中只要有抽象方法，必是抽象类。 



**12 抽象类和普通类有哪些区别？**

普通类不能有抽象方法 抽象类可以包含普通方法

抽象类不能直接实例化 普通类可以



**13 抽象类可以用final修饰么 ？**

不行 抽象类就是要让其他类继承的



**14 抽象类和接口的区别**

抽象类需要使用extenns 继承 单继承 

 接口用interface 继承  多继承

抽象类可以有构造函数  接口不可以 

接口方法 默认使用public修饰  抽象类方法可以使用任意修饰符

**15 java io分为哪几类？**

按照功能 输入流 输出流

按类型 字节流和字符流 字节流8位 传输数据 byte 字符流根据编码来的  utf-8一个中文字符三个字节 一个中文标点三个字节 一个英文字符或者标点一个字节

writer reader inputstream outputstream 四个抽象类

**16 bio nio aio**

bio 同步阻塞式io 平常传统的io 简单方便 并发处理低

nio 同步非 阻塞io 传统io 的升级 客户端和服务器通过channel通信  实现多路复用

aio 异步非阻塞io 



**17 判断一个数是否为 2的n次？**

​			一个数如果是2 的n次方 那么他的二进制数 必然只有1 个1  其他位都为0 

该数 -1 则 1的位置变为0 后面的都为1  进行与 运算 结果必然是0 



**17 java容器有哪些** 

分为 collection和 map两大类

collection 接口下

​		List 接口 

​	arraylist linkedlist vector stack

​		set接口 

​	hashset linkedhashset treeset

​		queue接口

​		blockingqueue

map 接口

​			hashmap  linkedhashmap hashtable 

​		concurrenthashmap



**18 collection 和collections有什么区别？**

collection 是集合接口 所有集合都是他的子类

collections是一个工具类，包含了很多静态方法，不能实例化(构造方法时private) collections.sort(list)



**19 List Set Map 之间的区别是什么？？**

|              | 是否有序 | 是否允许重复元素 |      |
| ------------ | -------: | ---------------- | ---- |
| list         |       是 | 是               |      |
| set  hashset |       否 | 否               |      |
| set  treeset |       是 | 否               |      |
| map hashmap  |       否 | 否               |      |
| map treemap  |       是 | 否               |      |



20 **hashmap 和 hashtable的区别**

​	存储 hashmap允许有key或value ==null

​			hashtable 不允许

​	线程安全 hashmap线程不安全

​					hashtable线程安全

单线程建议使用hashmap  多线程使用Concurrenthashmap



21 **什么时候用hashmap 什么时候用treemap？**

map中进行插入 删除 定位元素建议使用hashmap

如果对map 的key 进行有序遍历 可以使用treemap

22 **hashset的原理？**

​	hashset是基于hashmap实现的 ，不允许有 重复的值。

23 **ArrayList 和linkedlist 的区别？**

数据结构实现 ArrayList 是基于数组实现的

​						linkerlist是基于一个双向链表实现

随机性访问 建议使用 ArrayList 因为linkerlist是线性的数据存储方式，需要指针向后依次查询。

添加删除  在非首尾的情况下 linkedlist效率更高。因为arraylist  添加数据会影响别的数据的下标。 

|               | ArrayList                         | LinkedList               |      |
| ------------- | --------------------------------- | ------------------------ | ---- |
| get           | 根据下标获取O(1)                  | 遍历链表O(n)             |      |
| add(E)        | 尾部添加 O(1)                     | 尾部添加O(1)             |      |
| add(index，E) | 指定位置添加O(n),要移动后面的单位 | 查询后，指针指向操作O(n) |      |
| remove        | O(n)                              | O(1)                     |      |



24如何实现数组和list的转换？

 数组转list  Arrays.asList(array)

List转数组 LIst.toarray() 



25 Arraylist 和vectory的区别？

​	arraylist 线程不安全 vectory加入了synchronized，但是效率低。

都会根据实际情况自动扩容。

26 array 和ArrayList的区别？

array 可以存放基本数据类型 和对象  arraylist只能存放对象

array 可以指定 大小 arraylist 自动扩容

arrylist  有很多方法  addall removeall itertator等等

27 queue中 poll 和remove 方法有什么区别？

​	都是 返回第一个元素 并删除

  如果没有元素  remove 会抛出 NoSuchElementException  异常

​							poll 会返回空值



28  哪些集合类是线程安全的？

​	ArrayList linkedlist 不安全 hashmap

​	vectory 安全  hashtable 安全  ConcurrentHashMap。 

​	jdk 1.5之后出现 concurrent 包后 出现了对应的线程安全类



29 迭代器是什么？

​	iterator接口 提供遍历所有collection 的接口，我们可以通过一个collection中调用迭代器方法获得迭代器实例。

```
public interface Collection<E> extends Iterable<E> 
```



```java
List<String> list = new ArrayList<>();
Iterator<String> it = list. iterator();
while(it. hasNext()){
  String obj = it. next();
  System. out. println(obj);
}
```



30 iterator 和listiterator 有什么区别？

 iterator 可以遍历 list和set  listiterator只能遍历 list

​				只能单向遍历                           可以双向遍历

listiterator 从iterator继承 添加了一些额外的功能



31 如何创建一个只读集合 ？  

​			Collection.unmodifiableCollection(list );

32 oracle jdk 和 openjdk的区别？

​	一个是商业版一个是非商业版



112. spring cloud 的核心组件有哪些？

- Eureka：服务注册于发现。
- Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。
- Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
- Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。
- Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。



## 2 数据结构

### hashmap

​	**构造方法** 

**Initial Capacity**默认初始的桶大小     16

**Load Factor**负载因子    0.75

**size**   hashmap中装了多少的node 每次添加新的元素进去会加一 如果是key相同的替换则不加

put 方法 

​		1 首先判断 hashmap中是否有tablle 如果没有则创建

​		2 通过 hash（key）&table.length判断应该插入数组的具体位置

​		3 判断该数组位置 是否有数据 如果没有 则他当第一个元素

​		4 如果有 那么判断和第一个元素的key 是否相同如果相同 替换value 如果不同向下循环

​		5 判断是否相同如果相同 替换value 如果没有不同的数据 把自己添加在最后的位置上



resize方法 

​		什么时候扩容？

​	每put进一个元素，size+1 当size超过了 负载因子×表大小 则进行扩容。	扩容大小为当前表的两倍。

​		如何扩容？

​	1 建一个两倍大小的new table数组

​	2 在旧表中进行循环， oldtable【j】 如果当前的节点的下一个节点为null，则将这个节点直接扔到新表中同样的位置。

​	3 如果当前节点的下一个节点 存在 	那么就新建两个链表

​		第一个链表 在新table中放在同样位置的链表 

​		第二个链表 在新table中放在 当前位置+旧table长度的位置

​	判断的机制   hash(key) &16-1 比如 等于15 那么表示 hash（key) 的后四位 为1111   

​	用hash(key) & 16 旧表长度 

​		得到的数据 只有两种结果  要么为 1 0000 要么为 0 0000  结果为1 0000 的元素 放在 第二个链表上去 0 0000结果的数据放到  第一个链表上

​	完成扩容 



 jdk 1.7和 1.8中hashmap的区别？

​	1 1.7中hashmap 使用的是头插法，即每个新加入的数据都放在第一个的位置，1.8是尾插法 ，数据放在最后

​	2 jdk 1.8引入了 红黑树存储数据

在多线程中都是不安全的 

​	1.7jdk在扩容的时候 可能会发生 死循环  

​	1.8 在put数据时及嗯呢该会发生数据覆盖的情况（put的时候 如果在table中这个节点是空的 那么就会直接把当前的元素放上去 如果多线程操作的号  就会挤掉一个）



concurrenthashmap

​	concurrent下实现hashmap多线程操作安全类，

​		jdk1.7 通过segment分段锁实现 +hashEntry数组实现

segment继承 ReentrantLock 

put 方法 当执行 put方法插入数据时，根据key的hash值，在segment中找到对应的位置，通过加锁机制插入数据。

A线程 执行 tryLock方法成功获取锁，把hashentry对象插到具体的位置。B线程获取锁失败，不断重复执行获取锁，64次 b线程被挂起。

A线程完成插入操作后，通过unlock()方法释放锁，接着唤醒线程B继续执行。

​	jdk 1.8中 对node数组 第一个节点加 synchronized 锁



### blockingqueue

阻塞队列

collection接口 - queue接口 - blockingqueue接口

**阻塞队列的实现**

​	arrayBlockingQueue 由数组结构构成的**有界**阻塞队列   

​	linkedBlockingQueue 由链表结构组成的有界(默认大小是integer.max )

​	synchronousqueue 不存储元素的阻塞队列 单个元素的队列

​	（put进去就一直阻塞 直到有 take拿出来）

**阻塞队列的使用**

​		1 add remove  超出或者 没有元素就会报异常

​		2 offer poll  offer超出返回false 就不填了 poll方法 没有元素就返回null 

​		3 put take  阻塞方法 如果满了 那么put就一直阻塞 不返回值

​		4 offer(e,time,unit) 设置一个时间期限  只阻塞 time 

## 3 多线程

### Callable

 接口 实现线程

```java
class thread2 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {
        System.out.println("2024");
        return 1024;
    }
}

 FutureTask<Integer> futureTask = new FutureTask<>(new thread2());
 	futureTask.run(); //可以启动这个线程
	futureTask.get(); // 可以获得返回值 
        
    Thread t00 = new Thread(futureTask);
        t00.start();
	//也可以启动线程
	//因为 FutureTask 也实现了 runnable接口 使用了适配器模式 传入接口

```

###  线程池

​	线程池的主要作用是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果数量超过了最大数量，超出的线程排队等候，其他的线程执行完毕，在从队列中取出执行。

​		可以实现线程复用，控制最大并发数，管理线程。

优点 降低资源消耗，通过复用已经创建的线程降低线程创建和线程销毁的消耗

​		提高响应速度，当任务到达时，任务不需要等到线程创建就能立即执行。

​		提高线程的管理型，可以进行线程的统一分配，调优和监控。

ThreadPool

​	通过ThreadPoolExecutor实现，默认的有三种线程池

```java
 ThreadPoolExecutor threadPoolExecutor = 
    		Executors.newFixedThreadPool(); //固定数线程
			Executors.newCachedThreadPool();//多线程
			Executors.newSingleThreadExecutor();//一个线程
```



**线程池的主要参数设计？**

- corePoolSize 线程池中的常驻核心线程数
- maximumPoolSize 线程池能够容纳同时执行的最大线程数 (后面生成的 包含了corepoolsize)
- keepAliveTime  多余的空闲线程的存活时间	
- unit 时间的单位
- newblockingqueue 阻塞队列  任务队列，被提交但尚未执行的任务
- ThreadFactory 线程工厂
- 拒绝策略

**线程池实现流程** 

​		当一个线程被提交到线程池中，先直接被 corepoolsize中的线程执行，如果超出corepoolsize，则将任务提交到阻塞队列中，如果阻塞队列装满，仍有新任务，则创建新线程处理任务，线程池中处理的线程数最大为 maxmumPoolSize,如果仍然有新任务被添加，则执行拒绝策略。过一段时间后，新增的线程进入空闲，则经过keepAliveTime后，线程销毁。

**线程池中的阻塞队列**

​		ArrayBlockingQueue 必须构造队列大小的队列，对象FIFO排序。

​		LinkedBlockingQueue	基于链表的阻塞队列，默认是integer.MAX_VALUE 大小的队列，对象FIFO排序。

​		PriortyBlockingQueue 类似于LinkedBlockingQueue  对象排队不是 FIFO	

​		SynchronizedQueue  队列中不存放任务，必须是放和取交替完成。

**拒绝策略** 

​		当队列满，无法增加新任务，且线程池中的处理线程也达到了max，无法为新任务服务，则需要执行拒绝策略。jdk中自带四种拒绝策略。

​		1 AbortPolocy 默认策略 直接抛出异常阻止系统正常运行

​		2 DiscardPolicy 直接丢弃后续提交的任务

​		3 DiscardOldestPolicy 丢弃等待时间最长的任务 重新提交被拒绝的任务

​		4 CallerRunsPolicy 由调度的线程去处理该任务(main)



q1 **并行和并发有什么区别**？

- 并行 是指多个处理器同时处理多个任务，同时进行。

- 并发 是指一个处理器处理多个任务，按时间片轮流执行，多个任务交替执行。

  如果系统只有一个cpu那么只能是并发执行，只有多个cpu才可以并行。

q2 **线程和进程的区别**？

- 进程  在操作系统中能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序。 每一个进程都有自己的地址空间。 

- 线程 线程是cpu调度和分派的基本单位（资源调度的基本单位）， 能够完成进程中的一个功能， 他可与同属一个进程的其他的线程共享进程所拥有的全部资源。

-  联系

  进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 。

- 区别

  根本区别 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。

  开销方面 进程有独立的代码和数据空间，程序之间切换有较大的开销，线程可以看做轻量级的进程，

  所处环境 一个操作系统可以同时运行多个进程 同一个进程中有多个线程同时执行。

  内存方面 系统在运行的时候会为每个进程分配不同的内存空间，而对线程而言，除了cpu外，系统不会为线程分配内存，线程组之间只能共享资源。

q3 **线程的生命周期和状态**？

​		初始状态  	实现runnable接口 集成thread 可以得到一个线程类，new生成一个实例，进入初始状态。

​		就绪状态 调用start方法，线程进入就绪状态   就绪状态就是有资格运行，等到调度程序选择。

​		运行状态	就绪态的线程被调用并获取处理器资源时，线程进入运行状态，自动调用run方法，。

​		 阻塞状态  线程因为一些情况，让cpu暂时中止自己的执行，进入阻塞状态，sleep IO操作 企图或者一个锁而当前锁被其他线程持有。

​		 死亡状态  线程不可调度，不会获得cpu调度，run返回。

q4 wait() 和notify()之间的关系？

​	都是object类上的方法，wait是指当前线程 释放他所持有的锁进入等待状态。等待唤醒。

​						notify（） 唤醒此对象监视器上等待的单个线程。

​	wait和notify会对对象的锁标志进行操作，所以必须在synchronized中调用。



###  **JMM**

JMM是一种java内存模型的设计规范，目的是解决由于多线程通过共享内存进行通信时， 

 JMM主要是为了规定了线程和内存之间的一些关系。根据JMM的设计,系统存在一个主内存(Main Memory),Java中所有实例变量都储存在主存中,对于所有线程都是共享的。每条线程都有自己的工作内存(Working Memory),工作内存由缓存和堆栈两部分组成,缓存中保存的是主存中变量的拷贝,缓存可能并不总和主存同步,也就是缓存中变量的修改可能没有立刻写到主存中;堆栈中保存的是线程的局部变量,线程之间无法相互直接访问堆栈中的变量。 

1 **java内存模型**

 ![img](https://gitee.com/guoguoguoguo101/pic/raw/master/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjMTk4MmUzNjA5YjE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ) 

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。



#### 三大特性 

- 原子性

   指一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰 

- 可见性

   指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。 volatile、 synchronized、ﬁnal三个关键字可以实现可见性  

- 重排性

   如果在本线程内观察，所有的操作都是有序的；如果在线程中观察另外一个线程，所有的操作都是无序的。（前半句是指"线程内表现为串行"，后半句是指"指令重排序"和"工作内存与主内存同步延迟"现象。） 

####  volatile 关键词

​	 volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。 



- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）

- 禁止进行指令重排序。（实现有序性）

  

  在线程执行的时候，首先会从主存去读取数据，load到工作内存的副本中，然后才进行处理器操作，当执行完毕后，再把工作内存中的值传回给主存。

  ​	 从三个特性来说，原子性，  Java中，对基本数据类型的读取和赋值操作是原子性操作 ，原子性操作不可终端，一定要完成，被称为原子性操作。

  ​	有序性

  ​	 JMM是允许编译器和处理器对指令重排序的，  JMM保证了重排序不会影响到单线程的执行 。但是在多线程中就会产生一些错误，可以加上volatile，禁止重排。

  ​	可见性，当一个被volatile修饰的变量，对他的修改会立即刷新到主存。

   

  volatile主要从 可见性和有序性实现，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。		但是保证不了原子性，要想保证原子性，只能借助于`synchronized`,`Lock`以及并发包下的`atomic`的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。

- 底层的实现机制

  volatile关键字代码生成汇编代码，关键字前会多一个lock前缀指令。

- 使用场景

  适合一个线程写，其他线程进行读取的操作。如果有多个线程并发写操作，还是要加锁。。。

  单例模式双重锁结构。

  

  



2 指令重排 

​	在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是指令重排。
3  内存屏障 

 4）happen-before原则 



5 **单说说你了解的类加载器，可以打破双亲委派么，怎么打破。**

- 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。 最顶层的加载类，主要**加载核心类库**  
- 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。 **加载JRE的扩展目录** 
- 应用程序类加载器（Application ClassLoader）。**负责加载用户类路径（classpath）上的指定类库**，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

 6 双亲委派

​	当一个类加载器收到类加载请求，他不会去加载这个类， 而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。 

比如object类，不管哪个类加载这个类，都要到 自己的父类 加载，不会出现多个重名的class。



​	怎么打破双亲委派模型？

​		打破双亲委派机制则不仅**要继承ClassLoader**类，还要**重写loadClass和findClass**方法

三大特性

三 jmm

Java内存模型(Java Memory Model，JMM)JMM主要是为了规定了线程和内存之间的一些关系。根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。


### 	锁

java.util.concurrent

java.util.concurrent atomic

java.util.concurrent locks



锁的类型 

- **公平锁 非公平锁**

   公平锁是指多个线程按照申请锁的顺序来获取锁。 

   非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。 

  非公平锁 吞吐量比公平锁高，reentrantlock , synchronized 默认都是非公平锁。 （reentrantlock可以改为公平锁，后者不行）

  

- **可重入锁**

  ​		同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁代码。

  ​		线程可进入任何一个 它已经拥有锁的 同步代码块。 

  ​	public sync eat(){

  ​		drink();

  ​    }

  ​	public sync drink(){};

  ​	优点 避免死锁

  

- **独享锁 共享锁**

  独享锁指该锁一次只能被一个线程占有

  共享锁指该锁可以被多个线程占有

  ​	对于Reentrantlock来说，是一个独享锁。但是lock的另一个实现类ReadWriteLock的写锁时独享锁，读锁是共享锁。

  ​	Synchronized 也是独享锁。

- **互斥锁  读写锁**

  独享锁就是互斥锁的实现， 读写锁就是lock下的readwritelock锁

  ​	

  ```
      private final ReadWriteLock rwlock = new ReentrantReadWriteLock();  
      private final Lock rlock = rwlock.readLock();
      private final Lock wlock = rwlock.writeLock();
  ```

  

- **乐观锁 悲观锁**

  乐观锁和悲观锁不是指具体的什么类型的锁，而是看待并发同步的角度。

  悲观锁认为对于同一个数据并发操作，一定会发生修改，哪怕没有修改也会认为是修改，因此对于一个数据的并发操作，悲观锁采取加锁的形式，悲观的认为不加锁并发操作一定有误。

  乐观锁认为对一个数据的并发操作，不会发生修改的。在更新数据时，尝试更新，不断重新获取的方式更新数据。；乐观锁认为不加锁的并发操作没有问题。

  悲观锁适合写非常多写操作的场景，乐观锁适合有非常多读操作的场景。因为不加锁可以带来巨大的性能提升。

  悲观锁 在java中就是各种锁的实现。

  乐观锁即无锁编程，常用CAS算法，原子类通过cas自旋实现原子操作的更新



- **分段锁**

  分段锁是一种锁的设计， 对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。 

  concurrenthashmap中的分段锁又被称为Segment

   当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。 

- **自旋锁**

 自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁， 

​		自旋锁的实现

​	

```java
public class SpinLock {

  private AtomicReference<Thread> sign =new AtomicReference<>();

  public void lock(){
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current)){
    }
  }

  public void unlock (){
    Thread current = Thread.currentThread();
    sign .compareAndSet(current, null);
  }
}
```

 可以使用  AtomicReference<Thread>的.compareAndSet方法实现 自旋锁， 当一个线程占用锁时，另一个想要占用该锁的线程，不断while循环试图获得锁，当前者释放锁后，后者即可立即获取锁。



​	**优点**	 不会发生线程切换，一直处于用户状态，线程一直都是active，不会进入阻塞状态，减少了上下文的切换，执行速度快。

 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能） 

​	**缺点** 	当一个线程持有锁的时间过长，导致其他等待获取锁的线程就会一直进行循环等待，cpu使用率大大提高。

​       自旋锁是不公平的， 即无法满足等待时间最长的线程优先获取锁。 





q1 解决线程同步和互斥的常见方法?

​		三种 Cas、Synchronized、和Lock。 

q2synchronized和lock 的区别？

​		1 synchronized属于jvm层面，是关键字。

​			monitorenter (底层是通过moniter对象来实现的，wait和notify 也依赖 monitor对象)

​			monitorexit来实现的。

​			lock是具体的类，是api层面的锁。

​		2 使用方法 synchronized不需要主动释放锁，会自动释放锁。

​							lock需要手动释放锁，如果没有就会出现死锁。

​		3 synchronized 中的代码不可以中断， lock 可以中断 ，设置超时方法

​				 trylock（long timeout,TimeUnit unit）, lockinterruptibly()放入代码块中，调用 interrupt				方法中断。

​		4	synchronized是非公平锁，reentrantlock可以公平或者非公平。

​		5 绑定多个条件condition

​			synchronized没有condition

​			reentrantlock用来分组唤醒需要唤醒的线程们，可以精确唤醒。 synchronized只能随机唤醒			或者全部唤醒。



​	q3 synchronized 锁升级过程

​			无锁 偏向锁 轻量级锁 重量级锁，通过不断竞争 来实现锁的升级。



​	q4 q4 synchronized 是什么以及是怎么实现的？

​	synchronized关键字可以保证被他修饰的方法或者代码块在任意时刻只能有一个线程执行。

​	synchronized三种实现

- 对于普通同步方法 锁的当前实例对象
- 对于静态同步方法锁的是当前类的class对象
- 对于同步代码块 锁的是synchronized括号里配置的对象

​		synchronized同步语句块使用的是 monitorenter和monitorexit指令实现的，monitorenter指令指向同步代码块开始的位置，monitorexit指令则指明同步代码块结束的位置。当执行monitorenter指令的时候，线程视图获取锁也就是monitor的持有权，当计数器为0获取成功，获取后将计数器置为1，在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取失败，则进入阻塞状态。

通过对对象加锁，在jvm中 对象在内存中分为三块， 对象头 实例数据和 对齐填充。monitor就在对象头部分，所以synchronized可以对任意对象加锁。



​	q5  synchronized和lock的实现？

​			synchronized是通过monitorenter和 monitorexit实现的，获取对象monitor实现。

​			lock 内部一个int，用于锁的状态变更， 一个双向链表用于存储等待中的线程。获取锁的时候，通过CAS来获取状态值的修改，如果没有获取到则将线程放在等待链表中，释放锁则更改状态值，调整等待链表。

​			整个实现工程中，lock使用大量的cas+自旋，所以建议在低锁冲突的情况下使用。jdk1.6之后官方对synchronized做出了大量的锁优化，偏向锁，自旋，轻量级锁等，所以在非必要的情况下，建议使用synchronized进行同步操作。



### cas

 Compare and Swap  比较再交换

一种无锁的算法机制，cas 有三个操作数，内存中的值 ，期望内存中的值，要修改的新值。

当需要更新数据时，首先判断 预期内存的值和 内存中的值 是否一致 ，如果一致，则修改值为 新值，如果不一致 ，重读内存中的值 ，再次进行比较。

​	atomicInteger中运用 

​		atomicinteger 执行 incrementAndGet，利用了 unsafe类中的，运用do while 首先读取内存中的值，然后调用native方法，cpu指令元语， 进行比较然后赋值 ，c如果 相同则更改数据，如果不同则再次进入while 循环，重新读取内存中的值 ，再次进行对比 和赋值 ，cpu执行 比较并 赋值是一条原子指令，实现了操作的原子性。可以实现数据一致性。

​	example

- 1 主存中 放置一个atomicInteger  = 3 ，a线程和b线程都拷贝了一份副本 为3

- 2 a线程 读取到了 atomicInteger 后线程 就被挂起了。

- 3 b线程读取到了 atomicInteger 后，是3 ，进行compareAndSwapInt 比较发现 预期值和主存中额值是一致的，然后进行修改atomicinteger 为4。

- 4 a线程继续 ，进行compareAndSwapInt操作，发现主存中的值和 当前预期的值不是一致的 ，然后 就失败，重新 get 当前值，因为 value 是volatile 的类型，所以说别的线程修改后，他的线程可以立即看到。
- 5 a线程 再次去比较内存中的值 4和 预期值 4 ，相同 ，重新赋值。



缺点

- 循环时间长 ，开销大， 如果失败就会一直不成功，开销大。

- 只能保证一个共享变量的操作，对于多个共享变量的操作只能加锁。

- ABA问题  取出内存中的数据，在进行 cas操作时，中间的时间差可能产生问题。另一个线程 将这个数，A-B-A 修改，cas 仍然会交换成功，不知道数据已经被修改过。

  ​		ABA 问题  的解决 可以增加一个版本号，每次内存中的value 被修改后，版本号+1

  ​		 AtomicStampedReference  内部维护了对象值和版本号。

### question

​	1 两个线程操作，一个写数字一个写英文轮流操作？

```java
public class end29 {
   private Lock lock = new ReentrantLock();
   private Condition condition = lock.newCondition();
   private int t = 1;
    private char mychar = 'a';
   public void eng(){
       try {
           lock.lock();
           while (mychar<123){
               System.out.println(mychar);
            mychar++;
               condition.signalAll();
            condition.await();
           }
       }catch (Exception e){
       }finally {
           lock.unlock();
       }
   }
   public void num(){
       try {
           lock.lock();
           while (t<28){
               System.out.println(t);
               t++;
               condition.signalAll();
                condition.await();
           }
       }catch (Exception e){

       }finally {
           lock.unlock();


```





## 4 常用工具

### 消息队列MQ

​	ActiveMQ RabbitMQ RocketMQ  kafka

​	RabbitMQ  erlang语言 天生具备高并发的特性，性能比较好，社区活跃度高，不适合做二次开发和维护。

​	kafka 吞吐量高，适用大量互联网数据和服务收集业务。

​	rocketmq 并发量高，可靠性高，阿里的产品。

 优点

​		1 **解耦** 多个系统之久通过网络的方式互相调用，可以使用mq的方式异步通讯，当多个系统需要同一个程序的数据时，如果某一个程序异常，那么就会影响所有系统， 使用消息队列，就只是将消息压在队列中，没有被消费，不会对其他系统产生影响解耦。

​		2 **异步** 当一个操作需要好几个步骤，这些步骤不需要同步去完成，如果每个系统按顺序直接进行调用会浪费大量时间，可以将需要的操作放到mq中 异步操作，加快效率。

​		3 **削峰** 有流量高峰和流量低峰，当有大量流量访问我们的系统，系统就会崩溃，我们可以将消息放到mq中，按系统的消费能力解决，保证系统稳定，返回给客户一些特定的页面，

 缺点 

​		1 **系统可用度降低** 系统可用性低，mq挂掉 ，系统引入外部依赖越多，系统越复杂，容易出错。

​		2 **系统复杂度提高** 有可能出现重复信息，消息丢失，消息顺序等问题。

​		3 **数据不一致**A返回给客户成功操作，BC操作都执行成功 ，D操作失败。

### 	docker

 Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。 

## 5 JVM

### 1  JVM主要组成部分

- 类加载器（ClassLoader）
- 运行时数据区（Runtime Data Area）
- 执行引擎（Execution Engine）
- 本地库接口（Native Interface）



首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。** 

 ![img](https://img-blog.csdnimg.cn/20190515000239114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxNDc1NzAzOTgw,size_16,color_FFFFFF,t_70) 

### 2 运行时数据区

#### 1 虚拟机栈

(线程私有)



​	 ![img](https://jaybril.oss-cn-shenzhen.aliyuncs.com/wchat/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%BB%84%E6%88%90.png) 

​	虚拟机栈由若干栈帧组成

每个方法被执行都会产生一个栈帧 

局部变量表**  存储方法中的局部变量  当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。 

操作数栈 

指向运行常量池的引用

方法返回地址





#### 2堆 

(线程共享)

最大的一块内存空间，存放各类的实例对象。

java堆被划分成了两个不同的区域，新生代，老年代。

新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 



新生代 1/3 堆空间

​		Eden 8/10  From Survivor 1/10 To Survivor 1/10

老年代 2/3堆空间

产生的对象放到eden中，如果存储满了，发生gc，将eden中存活的数据放到 from区，清空 eden， 当eden再次填满的时候，将eden和from区的存活对象放到 to区。 清空from和eden。

老年代  每进行一次GC，存活对象的年龄+1， 到15的时候进入老年代，

 当堆区的内存不够用时， 或者没有连续内存可以容纳一个较大的对象时， 就会触发垃圾回收 

##### 垃圾回收

**1 如何判断一个垃圾是不是垃圾？**

**引用计数法**

 		很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。 

**可达性分析算法**

​	 一系列的“GC Roots”对象作为起点进行搜索，  通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。 

​	对象包括以下

​		1 虚拟机栈中引用的对象

​			 1)首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。 

​		2 方法区中的静态属性引用的对象 ，我们在类中定义了全局的静态的对象，也就是使用了static关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。 

​    (3)第三种便是常量引用，就是使用了static final关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。最后一种是在使用JNI技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用native方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。 

**2 JVM回收垃圾机制**

- 清除算法

   首先标记所有需要被回收的对象，再标记完成后统一回收所有被标记的对象。 

  标记和清除的效率都较低，会产生大量内存碎片，导致多次触发GC。

- 复制算法

   复制算法将内存分为大小相等的两块，每次只是用其中一块，当第一块内存的空间用完了时， 触发GC回收， 然后将还存活的对象直接复制到第二块内存， 然后把第一块内存直接清空掉， JVM堆新生代使用该算法进行垃圾回收。

  ​	缺点 将内存缩减为原来的一半，存活对象较多的情况下，效率较低。

  ​	优点  存活对象较少的情况下，效率很高。

- 标记整理算法

   标记不回收的对象移动到一端，然后清除边界以外的内存 

- 分代收集算法

  将堆分为 新生代和老生代，新生代的垃圾回收使用复制算法，老生代使用标记整理算法。

**3 垃圾回收器**

**新生代收集器**：Serial、ParNew、Parallel Scavenge G1

**老年代收集器**：CMS、Serial Old、Parallel Old  G1





7.说说你知道的几种主要的JVM参数

- -Xms2g：初始化推大小为 2g；
- -Xmx2g：堆最大内存为 2g；
- -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
- -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
- –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
- -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
- -XX:+PrintGC：开启打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息。

​	设置堆大小，年轻代大小，线程的栈大小。老年代大小，年轻代与老年代的比值， 设置垃圾最大年龄  如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。  选择垃圾收集器为并行收集器。 



8强引用、软引用、弱引用、虚引用的区别？

​	强引用  new一个对象，内存不足的情况下，抛出outofmemory 也不会回收这个对象。

​	软引用 内存足够就不会回收，内存不足就会回收。

​	弱引用 只要被发现，立马被回收。

​	虚引用  如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。  虚引用的用途是在 gc 时返回一个通知。 



对象本身和数组



#### 3方法区

(线程共享)

 类型信息和类的静态变量都存储在方法区中 

 存放已被加载的类信息(类名 类的类型 class interface 访问修饰符父类的类型 实现的接口 )、常量池，字段信息，方法信息、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享 

#### 4本地方法栈

(线程私有)

#### 5程序计数器

(线程私有)

​	1   字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 

​	2 在多线程的情况下，程序计数器用于记录当前的运行的位置， 从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了 。

记录当前线程所执行的字节码的行号显示器 

 当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有 





 



































## 6 MySQL

### SQL语句

数据库基本sql语句

SUM 求和

count 数量累计

groupby 分组  后面+having 分组条件判断

order by 按顺序排列 desc 由大到小   

left join  table  on 

limit 



###  索引

mysql 的索引默认是使用B+树实现的。

1 **二叉树** 使用时![1584622007940](https://gitee.com/guoguoguoguo101/pic/raw/master/1584622007940.png)

如果数据是递增的情况下，还是会逐一查询。性能较低。



2 **红黑树** 红黑树数据会自动平衡成完全二叉树，但是数据较多的情况下，需要很高的高度，每一次io都会浪费很多时间，效率较低。



3 **hash** 每个节点 经过hash 存储在一个hash表中  查找速度很快 但是 如果碰到 > 或者 < 则无法利用索引搜索



4 **b树**  每个节点存储 很多个索引，还有自己所存储的数据。但是这样做的话，节点存储不了太多的数据，性能也比较低。



5 **b+树** b树的改进版，每个非叶子节点，存储索引 ，不存储数据。在每个叶子节点存储相应的唯一的索引和对应的数据。 每个叶子节点 存一个双向的指针 可以指向下一个叶子节点 。

![1584627046973](https://gitee.com/guoguoguoguo101/pic/raw/master/1584627046973.png)



b+树特点

1 一个节点可以存多个元素

2 所有的数据都存在叶子节点

3 叶子节点有指针 顺序排列



### **存储引擎**

(基于数据存储)

mysql的存储默认 引擎 innodb  ， MyISAM

 一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。 

 对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，*。

 于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。 



**innodb引擎**   

.frm 表结构 

.ibd （ index data）   



**myisam引擎**

.frm 表结构 

.MYD 表中的所有数据

.MYI 索引



**两个引擎的区别** 

**innodb** 支持事务，支持ACID事务特性，支持四种隔离级别 支持行锁

可以利用事务日志进行数据恢复，可以缓存数据。使用行锁，适合高并发的修改，系统开销比较大。

缺点 没有保存表的行数，使用count时会扫描全表。

**myisam** 引擎 高性能读取，使用count时不会扫描全表。锁为表锁，开销小加锁快不支持事务，也不支持外键。



​			



**q1 为什么innodb必须有主键，且推荐使用整形的自增主键？**

1  如果设置了主键，那么InnoDB会选择主键作为聚集索引、 如果没有定义主键， nnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引 ，如果没有则使用内置主键( 内置6字节长的ROWID  作为隐含的聚集索引(ROWID随着行记录的写入而主键递增)。



2 如果使用自增主键，每次插入数据都会按顺序添加到当前索引节后面的位置，主键的顺序按照插入顺序排列，自动有序。当一页写满就会开辟新的一页。



3 如果使用非自增主键，uuid 学号 身份证号等，插入主键的值 是随机的，每次的新纪录都会被插到现有索引页中的某个位置，需要移动数据位置，造成很大消耗。



**q2 MySQL的索引类型？**

 聚集索引   聚集索引表示表中存储的数据按照索引的顺序存储 

 非聚集索引  除了主键以外的索引 



 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。



主键索引 ，唯一索引，普通索引 ，组合索引，全文索引。

○ 查看主键索引  SHOW INDEX FROM table_name  它 是一种特殊的唯一索引，不允许有空值。 

○ 唯一索引  与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值 。

○  普通索引 ：最基本的索引，没有任何限制 

○  组合索引 ： 为了更多的提高mysql效率可建立组合索引 ， 即一个索引包含多个列 

○  全文索引 ：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 





**q3 多个单列索引和一个组合索引哪个效率更高？**

执行sql查询的时候mysql只能使用一个索引，选择最严格的一个索引，限制能力会远远低于组合索引。





q5  数据库三大范式？

​	第一范式 原子性 数据库表中的所有数据，都是不可分割的原子值，不能是集合，数组

​	第二范式 唯一性 实体的属性必须完全依赖主键，不能只依赖主键的一部分属性。

​	第三范式 冗余性  标是确保每列都和主键列直接相关,而不是间接相关.  属性不依赖于其它非主属性 

### 事务

q6 mysql事务的四个特征 ACID 

  原子性Atomicity 一致性Consistency 隔离性lsolation 持续性Durability

1 原子性 事务是数据库的逻辑工作单位，事务中的操作，要么都做，要么全都不做。 事务不可分割、不可约简。 

2 一致性   一致性是指事务执行前后，数据处于一种合法的状态，满 足预定的约束就叫做合法的状态， 通过另外三个属性满足一致性。

3 隔离性  一个事务的查询结果不会被其他事务所影响，事务之间是隔离的。 

4 持续性  也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 不能回滚。



q7 mysql 事务的隔离级别？

​	 READ-UNCOMMITTED  未提交读 ，事务在未提交前，就可以被其他的事务读取。

​	  READ-COMMITTED  提交读   一个事务提交后才能被其他事务读取到 

​	REPEATABLE-READ  可重复读  可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务已提交的数据 。

 SERIALIZABLE 	序列化读 ，读取数据时，表被锁，不能添加或删除数据，效率较低。



|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | 是   | 是         | 是   |
| 提交读   | 否   | 是         | 是   |
| 可重复读 | 否   | 否         | 是   |
| 序列化读 | 否   | 否         | 否   |



**脏读** ：一个事务读取到另一事务未提交的更新数据。

**不可重复读**： 在同一事务中，多次读取同一事务返回的结果有所不同。 可重复读 ，在同一事务的多次读取数据时，能够保证所读数据一样，

**幻读** 事务在读取数据时，另外的事务往数据库中新增了数据，导致之前的事务，再次读取时，新增了数据。



总结 未提交读 就是 这个事务还没有提交，他更改的数据就可以被其他事务读取到了，会发生脏读。

​		提交读 ，改了上述的问题，但是一个事务在重复读一条 数据时，如果其他的事务对该数据发生修改，他就会读取新的值，是不可重复读的。

​		可重复读，就是 读取一条数据时，即使别的事务对当前的数据发生了修改，但读取还是不变，select操作不会更新版本号，是快照读。但如果插入了数据，就还是会被读出来，产生幻读。

​		序列化读 就是读的时候，把表锁了，别的事务不能对表进行操作。



q8 说说mysql常用引擎？

​		innodb 是mysql 5.1以后默认使用的数据库引擎，提供了对数据库ACID事务的支持，提供了行级锁和外键的约束，可以处理大数据容量的数据库系统，还提供了 故障恢复 。 运行时，还会创建缓存区，用来缓存数据和索引。但是该引擎不支持全文搜索，当执行select * from xx时，会进行全表扫描。由于锁的粒度较小，写操作不会锁定该表，在高并发下使用ok。

​		myisam 不提供事务的支持，也不提供行锁和外键，当插入和更新数据库时，会将全表锁定，效率较低。但是myisam引擎保存了行数，当进行select * 操作时，可以直接读取已经保存了的行数，不需要全表扫描。当读操作远远多于写操作，且不需要事务支持的时候，可以使用myisam引擎。

mysql的存储引擎和索引

​	 有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种**数据存储方式**。  对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。 

​		  **InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上**，  ，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。  **若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。**  **第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。** 

​	MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 ![img](https://img-blog.csdn.net/20141025120025957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdm9pZGNjYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

 https://blog.csdn.net/qq_28584889/article/details/88778741 



q9 mysql 的行锁和表锁？

​		mysql只支持表锁 ，innodb支持 表锁和行锁，默认行锁。

​		表级锁  开销小，加锁快，不会出现死锁，锁的粒度大，发生锁冲突的概率高，并发度低 



q10 基于锁的隔离级别的并发控制 LBCC和基于MVCC的隔离级别并发控制？

​	 **LBCC**

​		通过对读写操作加不同的锁，以及对释放锁的时机进⾏不同的控制，就可以实现四种隔离级别。 

​		传统的锁有读锁和写锁，

​	**MVCC** 

InnoDb  会为每⼀⾏记录增加⼏个隐含的“辅助字段”（ROWID、事物ID、回滚指针）。事务在更新⼀条记录时会将其拷⻉⼀份⽣成这条记录的⼀个原始拷⻉，写操作同样还是会对原记录加锁，但是读操作会读取未加锁的新记录，即通过维持一个数据的多个版本，使得读写操作没有冲突，保证了读写并⾏。

q 11. 说一下乐观锁和悲观锁？

- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。
-  数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 



q12 分库和分表？

 **数据库分布式核心内容无非就是数据切分（Sharding）** 

​	**1 垂直切分** 

​		垂直分库 

​			根据业务的耦合性，将关联度低的不同表存储在不同的数据库中，大的系统拆分成小的系统。

和微服务做法类似。 ![img](https://upload-images.jianshu.io/upload_images/6483443-e9846821809aec30.png?imageMogr2/auto-orient/strip|imageView2/2/w/914/format/webp) 

​		垂直分表 

 基于数据库中的"列"进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。  大表拆小表 ，表中字段长度短，访问频率高，加载到内存中，提升效率。



优点 

​		解决业务系统层面的耦合，业务清晰。

​		与微服务类似，可以对不同的业务的数据进行管理，监控，扩展等。

​		高并发场景下，垂直切分可以提高io，数据库连接数，单机硬件资源瓶颈。

缺点 	

​			部分表无法join 

​			分布式事务处理复杂

​			单表数据仍然过大

2 水平切分 

​	 当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。 

​	水平切分 分为库内分表和 分库分表 

​	将一个表按逻辑关系，分散到多个数据库或多个表中，每个表都只有一小部分数据。达到分布式的效果。

​		库内分表只解决了一个数据库内单表数据量过大的问题，大家还是竞争同一个 cpu 内存 硬盘网络io。

最好使用分库来解决。

优点 不存在单库数据量过大，高并发的性能瓶颈，提升系统的稳定性和负载能力。

缺点 事务的一致性难以保证

​		跨库的join关联查询性能差

​		数据多次扩展难度太大 需要大量维护

  切分规则 1 数值切分 扩展方便  可以快速定位分片进行查询 

​										热点数据出现瓶颈 历史数据很少查询

​					2 hashmode  数据分片均匀 不存在热点数据和冷门数据

​											缺点 扩容时 需要迁移旧的数据 分片查询比较复杂 如果查询的数据不带 那个hash的值 就根本找不到数据在哪 得从所有的库找



分库分表带来的问题



​		 事务一致性

​			1 分布式事务当更新数据时，提交事务需要协调多个节点，访问共享资源上容易发生死锁和冲突。

​			2 最终一致性  对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。 



​		 **跨节点关联查询 join 问题** 

 切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询。 



解决办法 

1 设计全局表

​		 全局表，也可看做是"数据字典表"，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，**可以将这类表在每个数据库中都保存一份**。这些数据通常很少会进行修改，所以也不担心一致性的问题。 

2  **字段冗余** 

​	 一种典型的反范式设计，**利用空间换时间**，为了性能而避免join查询。 

 订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询"买家user表"了。
但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。 



 https://www.jianshu.com/p/6129d51ce0ad 

### MySQL优化

1 字段优化

	- 尽量使用  TINYINT  SMALLINT MEDIUM INT 作为整数类型 而非INT，如果是非负 加上 UNSIGNED 
	- varchar 只分配真正需要的空间
	- 用枚举或整数代替字符串类型
	- 尽量使用TIMESTAMPE 而非 DATETIME 
	- 单表不要有太多字段 少于20
	- 避免使用null 字段 
	- 用整形来存ip

2 索引

	- 索引不是越多越好 尽量用在 where和order by 上
	- 用EXPLANIN来查看是否用了索引还是全表扫描
	- 尽量避免在where中使用 null 这样会放弃索引 全表扫描
	- 避免使用%前缀模糊查询 可以使用 name%模糊查询
	- 字符字段不做主键
	- 不使用外键
	- 使用 多列索引 注意字段的顺序，遵守最左前缀法则，常用的查询字段放在最前面。
	- 删除不必要的 单列索引

3 查询sql

	- 可以打开慢查询日志 查找出来较慢的sql
	- 尽量不在sql语句中使用列计算 比如 select * from user where id+1 = 10  这样会使用全表扫描
	- sql语句尽量简单 大语句拆成小语句
	- 不使用select *
	- OR 改成 IN
	- 减少 JOIN的使用
	- 避免在where后使用 ！=   > < 操作符 引擎将会放弃使用索引 进行全表扫描
	- 对于连续值 使用between 不用in 
	- 列表数据不要拿全表 使用limit分页
	- 





1 explain 查看这条sql ，type连接类型 要到达range类型，避免all类型。

​			○type 连接类型

​					all 查询表的所有内容

​					index  也查询了全表的数据， 遍历索引树查询 ， 通常发生在查询结果只包含索引字段时。 

​					range 一定是基于索引查询的，有范围的索引扫描。 > < between and in or 

​					ref  查找条件列使用了索引而且不为主键和unique。 

​					eq_ref  唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 

​					const  当查询最多匹配一行时，常出现于where条件是＝的情况。 

2 减少sql 中的in ，对于连续的数值，尽量用between 不用in

3 select 指明查询的字段，不是用slecet *

4 只需要一条数据时 ，使用limit 1 使得explain 中的type 达到const

5 排序的字段要设置索引，

6 or两边的字段，如果有字段没有索引，则不用or 可以用union 代替

7 使用union all 代替union 

8 使用分段查询

9 避免在where中使用null 这样会放弃 索引  避免使用%前缀模糊查询 可以使用 name%模糊查询

10  避免发生隐式的类型转换 ，where中查询的参数和 字段的参数不一致 

11 联合索引遵守最左前缀法则，常用的查询字段放在最前面。

12 尽量使用innerjoin  少用 leftjoin  innerjoin 使用的是小表作为驱动表，

13  尽量使用数字型字段  尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 

优化sql 语句，尽量避免all查询。使用索引 ，增加查询速度。



## 7 redis

 Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。 

### redis 持久化支持 

​	 **RDB**  通过快照的方式， 获得存储在内存里面的数据在某个时间点上的副本。 

 按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb， 

 可以对快照进行备份，将快照复制到其他服务器从而创建具有相同数据的服务器副本。



 **AOP** 

​	 Redis会将每一个收到的写命令都通过Write函数追加到文件最后，  当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 



 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。 



### **主从复制**

 是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；  数据的复制是单向的，只能由主节点到从节点。 、

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。

2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。

3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。

4. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

   

   **Sentinel哨兵模式**

   Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：

   **监控（Monitoring****）**： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。

   **提醒（Notification****）**： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

   **自动故障迁移（Automatic failover****）**： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会进行选举，将其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

   

1 为什么使用redis

  高性能 

用户第一次访问数据从硬盘上获取，速度较慢。将该数据放到缓存中，下一次读取就会直接从缓存中读取，速度很快，当改变数据库时，将数据同步到缓存中即可。

高并发

直接操作缓存的请求远大于数据库，可以将部分数据库内容放到缓存中，用户直接访问缓存，不需要经过数据库。



2为什么用redis 不用map？

​	缓存分为本地缓存和分布式缓存，java可以使用自带的map进行缓存，轻量快速，生命周期随jvm销毁而结束，在多实例的情况下，需要保存多份缓存，缓存不具有一致性。

使用redis称为分布式缓存，在多实例的情况下，各实例公用一份缓存数据，缓存具有一致性。



3redis 的线程模型

​	redis内部使用的文件事件处理器 file event handler，这个文件事件处理器是单线程的。

​	多个socket 

IO多路复用程序 

文件事件分派器 

事件处理器(连接应答处理器 命令请求处理器 命令回复处理器)



 多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。 

 https://www.javazhiyin.com/22943.html 



4 为什么redis单线程 效率也很高?

- 纯内存操作
- 核心是基于非阻塞的 IO 多路复用机制
- 单线程反而避免了多线程的频繁上下文切换问题



5 redis 和 memcached 的区别

1 redis支持很多数据类型，memcached 只支持string类型。

2 redis支持数据持久化，可以将数据保存到磁盘中，重启后可以再次加载。

3  **集群模式**：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的. 

4  **Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型** 



6 redis常见数据结构 

​	string  key-value 微博数 粉丝数

 hash   用户信息 商品信息

list  链表 ，双向。 支持反向查找和遍历，高性能分页。

set 无序集合 交际 并集 差集  共同关注，共同喜好共同粉丝 

zset sored set直播间在线用户 礼物排行榜 弹幕消息 





8 怎么保证缓存和数据库数据的一致性？

 1设置缓存 的过期时间

2 读的时候先读缓存，如果缓存没有则读取数据库，写的时候先更改数据库 然后删除缓存。 



8 redis 集群

  codis 

9 redis 多机部署 ，如何保证数据一致性？

	 主从复制，读写分离

一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库 



10 缓存穿透  缓存雪崩 和缓存击穿？

​		**缓存穿透**  正常是数据查询先查询缓存，没有则查询数据库，如果数据库有则把查询到的数据放到缓存中，如果没有则返回空，不放入缓存。 缓存穿透是指 查询一个数据库根本就没有的数据。

​		解决方法 采用布隆过滤器，将所有可能存在的数据hash到一个bitmap中，一个不存在的数据会被过滤掉，减小数据库压力，或者是查询结果为空，然后我们将空结果也放入缓存，设置比较短的过期时间。

​		**缓存雪崩** 缓存大量崩溃 ，，请求全部转发到db，压力过大引起雪崩。

​		解决方法 如果是集体过期，那么给缓存设置一个随机的过期时间防止同时过期。 实现redis高可用 使用主从架构和哨兵机制，使用redis集群，避免redis挂掉。 如果真的挂掉，我们使用本地缓存，和限流的方式防止系统崩溃。 发生过后，我们使用redis持久化，从磁盘上加载数据，快速恢复缓存数据。

​		**缓存击穿** 某一个热点数据，在某个时间突然过期，key失效的瞬间，请求击穿了缓存，直接访问数据库。

​		解决方法，实现互斥锁，当第一个请求构建完缓存之后，再释放锁，进而其他请求才能访问。































## 8 设计模式

单例模式

双重检查锁

```java
//懒汉模式
//线程根本就不安全 可以再getinstance上面加个锁

public Singleton{
    private static Singleton instance;
    private Single(){}
    public Singleton getInstance(){
       if(instance = null){
           instance = new instance;
       }
         return instance;
    }
}

//饿汉模式
public Singleton{
    private static Singleton instance = new Singleton();
    private Single(){}
    public Singleton getInstance(){
        return instance;
    }
}




public Singleton{
	public volatile static Singleton singleton;
    public Singleton getinstance(){
        if singleton == null{
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton
                }
            }
        }
    }
}

```

### 策略模式

```java
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
    
    

```



# 符合开闭原则的设计模式的例子**  list . Comparator 

## 9 算法题

### 链表

```java
  // 迭代实现 
  	// 定义一个pre 为null
    public static Node reverse(Node t){
        Node cur = t;
        Node pre = null;
        while (cur != null){
            Node next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }

// 递归实现
  // node.next.next  node.next = null
    public static Node reverse2(Node t){
        if (t.next==null||t==null){
            return t;
        }
       Node n0 = reverse2(t.next);
        t.next.next = t;
        t.next =null;
        return n0;
    }


```

### 树

树的遍历

- 深度优先

  前序 中序 后序遍历 

  中左右 左中右 左右中 



```java
 public static void pre(TreeNode treeNode){
        if (treeNode !=null){
            System.out.println(treeNode.val);
            arrylist1.add(treeNode.val);
            if (null!=treeNode.left)
                pre(treeNode.left);
            if (null != treeNode.right)
                pre(treeNode.right);
        }
    }
    
    public static void   middle(TreeNode treeNode){
        if (treeNode !=null){
            if (treeNode.left!=null)
               middle(treeNode.left);
            System.out.println(treeNode.val);
            arrylist2.add(treeNode.val);

            if (treeNode.right!=null)
                middle(treeNode.right);
        }
    }
    public static void   before(TreeNode treeNode){
        if (treeNode !=null){

            if (treeNode.left!=null)
               before(treeNode.left);
            if (treeNode.right!=null)
                before(treeNode.right);
        }
        System.out.println(treeNode.val);
        arrylist3.add(treeNode.val);
    }

```

- 广度优先

  一层一层遍历

```java

    public static void  levelorder(TreeNode head){
        System.out.println("head.val="+head.val);
        if (head!=null){
            LinkedList<TreeNode> l0 = new LinkedList();
            l0.add(head);
            while (!l0.isEmpty()){
                TreeNode  current = l0.poll();
                System.out.println("current = " + current.val);
                arrylist4.add(current.val);
                System.out.println(arrylist4);

                if (null!=current.left){
                    System.out.println("添加左节点"+ current.left.val);
                    l0.add(current.left);
                }

                if (null!=current.right){
                    System.out.println("添加右节点"+ current.right.val);
                    l0.add(current.right);
                }
                System.out.println(l0);
            }
        }
    }

```

- 树的子树交换

```java
  public static TreeNode invertTree(TreeNode root){
        if (root == null){
            return null;
        }
        TreeNode right = invertTree(root.right);
        TreeNode left = invertTree(root.left);
        root.left = right;
        root.right = left;
        return root;
    }
```





### 排序

快排 

时间复杂度 nlogn

```java

   public static void  quick(int[] nums,int start,int end){
        if (start>end){
            return;
        }
        int left = start;
        int right = end;
        int cur = nums[left];
        while (left<right){
            while (left<right&&nums[right]>=cur){
                right--;
            }
            //先从右边遍历 然后右边的数字传给左边
            nums[left] = nums[right];

            while (left<right&&nums[left]<=cur){
                left++;
            }
            
            //然后从左边找 左边的数字 传给右边
            nums[right] = nums[left];
        }
       //结束以后 cur的位置放到 两个指针重叠的位置
        nums[left] = cur;
        quick(nums, start, left-1);
        quick(nums, left+1, end);
    }
```



冒泡排序

```java
public void order(int[] nums){
    int le = nums.length;
    for(int i=0;i<le-1;i++){
        for(int j=0;j<le-i-i;j++){
            if(nums[j]>nums[j+1]){
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
}

```





## 10 网络协议

### 网络模型

网络模型  应用层 传输层 网络层 链路层 物理层



### http

http 基于tcp的处于应用层的超文本传输协议。

q1 一个http相应的 全过程

- DNS 根据域名进行映射，找对应网址的真实地址。http客户端，在80端口发起一个到服务器的tcp连接，在客户端和服务器之间有一个 套接字。
- http客户端通过套接字发送一个 http请求报文，
- http服务器通过套接字 接受到 报文，并解析，生成一个相应报文，并通过套接字 发送相应报文到客户端。
- http服务器通知tcp断开连接，等到客户端接受到相应报文后才会断开连接。
- http客户端接收完相应报文后，tcp连接会关闭。http客户端从相应中提取出报文中的html相应文件，并检查该html文件。
- http客户端把对应的资源显示给用户。 

q2 http请求特征？
- http支持 客户-服务器模式

- 简单快速 客户端给服务器发请求时，只需要请求方法和路径，请求常用方法有 get post head 每种方法规定了客户和服务器联系的类型不同。http协议简单，服务器规模较小。

- 灵活 http允许 任意类型的数据对象传输。

- http 是面向无连接的， 即每次连接只处理一个请求，服务器处理完客户的请求，并收到应答后，断开连接。

- http 无状态的，对事物处理没有记忆能力，如果后续处理需要前面的信息，必须重传，导致每次连接传送的数据量增大。

  ​	解决http无状态 

  ​	1 通过cookies保存信息，这样服务器就可以知道是不是来自同一个客户端。

  ​	2 通过seesion保存状态 服务器给每个session分配一个唯一的 jsessionid，并通过cookie发送给客户端，当客户端重新发送新的请求时，将cookie头中携带的 jessionid 。这样客户端可以找到对应的session。

  ​			可以通过cookie

  ​			可以通过表单隐藏字段

  ​			可以url重写 url后边加上session的 query字段

  ​	3 token 客户端通过账户密码，验证。服务器收到请求后，验证用户和密码，验证成功后服务端会签发一个token，客户端存储起来，客户端每次发起请求都带着token。服务器收到请求后，验证token是否正确，就向客户端返回请求。

  ​	4 jwt 

  ​	token的具体实现。

  5 oauth2 

  ​	向第三方平台进行鉴权。

q3 http报文？

​	http报文分为三大部分

- 起始行  描述请求或响应的基本信息； 

- 头部字段   使用 key-value 形式更详细地说明报文； 

- 消息正文    实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 

  起始行和头部字段 称为header 消息正文称为body。

 ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9saWJZUnV2VUxUZFdVeEdLdkpBMzFyeWpEVlNQUnVicTU3NEhJVnM1QkpTWXdvVVpQRXdpYXZPaWNUN2U0QXFWR3BoTWthZExKMkZ1OGNXaWJBQW44dHBWZGcvNjQw?x-oss-process=image/format,png) 

q4 常见状态相应码？

- 2XX

  200 成功 

  204 成功 但没有资源可以访问

  206 成功 对资源的某一部分进行相应 有content-range 指定范围的实体内容

- 3XX

  ​	301 永久性重定向，

- 4XX

  ​	400 请求报文有错误

  ​	403 请求被服务器拒绝

  ​	404 资源找不到

- 5XX

  ​	500 服务器报错了

  ​	503 服务器超负载或者正在进行停机维护

q5 http的优点和缺点

- 优点 

  ​	协议简单，主要组成就是header和body，请求方法中url可以任意指定

  ​	应用广发 环境成熟  跨平台 不限制编程语言和操作系统

  ​	无状态 服务器没有记忆能力，减轻服务器的负担 把更多的内存和cpu用来对外提供服务

- 缺点 

   	无状态 服务器没有记忆能力，无法支持连续多个步骤的事务操作，每次都需要问一遍身份信息，增加了很多传输量，出现了cookie技术。

  ​	明文  明文传输

q6 http1.0和http1.1的区别？

​	http1.1支持长连接，不需要每次请求都经过三次握手，四次挥手。

 Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接 

​	错误码 新增了错误状态响应码，409410等。

​	缓存处理 1.0中主要是用header头里的 `If-Modified-Since`、`Expires` 来做为缓存判断的标准；HTTP 1.1，则引入了更多的缓存控制策略，如 `Entity tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match` 等；

​	端口号不同 443 和8080

### tcp

q1 tcp的三次握手，四次挥手？

- 三次握手

​	tcp连接是通过三次握手来连接的。

​	第一次握手  当客户端向服务器发送请求时，客户端会发送同步序列号 syn 到服务器

​	第二次握手 服务器收到客服端发来的请求， 发送一个ack = 客户端发来的syn+1 ，告诉客户端你的请求收到了 ，然后发送一个syn。

​	第三次握手 客户端 收到服务器发来的包，向服务器发送ack包 ack = 服务器发来的syn+1 ，告诉服务器我也能收到你发的消息。建立连接！



- 四次挥手

  A端B端断开连接时

  第一次挥手 A端向b端发出 fin标记的报文段，fin是finish的意思

  第二次挥手 B端 收到fin后，先发送 ack 表示确认收到，但数据还可能没有发完

  第三次挥手 b端处理完数据，向a端发送 fin序号，表示可以断开连接了

  第四次挥手 a端收到 fin后，向b端发送 ack 表示断开连接 M，经过两个msl 断开连接。

q2 为什么不是两次或者是四次？

​	不能是两次， 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 。

当客户端发送的请求报文被网络滞留了，是一个失效的报文，但是server还会收到报文，并发出确认报文，建立连接。但是client不会理会server，也不会向server发送ack包，这样就会浪费资源。

q3 tcp和udp 的区别？

​	tcp面向连接，双方通信前需要建立连接，才能完成数据传输。并且可以实时监控数据。

​	udp不面向连接，传输数据时，直接向网络节点发送数据。

​	tcp 提供可靠的数据传输服务，udp不行。

​	tcp 慢，udp块。 tcp面向字节，udp面向报文。

q4 tcp 和udp对应的协议？

- tcp 

  ​	ftp文件传输协议 21端口	

  ​    telnet 远程登录的端口 23端口

  ​	smtp 邮件传送协议 25

  ​	pop3 邮件接收协议 110

  ​	http web服务器传输超文本到本地浏览器的传送协议 80

- udp

  ​	dns 域名解析服务

  ​	snmp 网络管理协议

  ​	tftp 69


​	

## 11 异常类

 ![img](https://img-blog.csdn.net/20180920165502957?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pY2hhZWxnbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

所有异常都是继承Throwable继承来的，是所有异常的共同祖先。

Throwable有两个类

​	Error 虚拟机运行异常以及系统异常等。程序不能处理。

​	Exception 来表示java中可能出现的异常，并且合理的处理这些异常。

​			分为 RuntimeException运行时异常和 IOException IO异常



## 12 反射

反射  

允许运行中的java程序获得自身的信息，并且可以操作类和对象的内部属性。

 **通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等** 。



## 13 Spring

### AOP

​		面向切面编程，即扩展功能但不改变原代码实现。

​		采用横向抽取的机制，可以完成性能监视，事务管理，安全检查，缓存等。

Spring AOP的底层实现有两种方式 

​		1 JDK动态代理的方式

​		2 CGLib的方式

- JDK动态代理

  ​	通过java.lang.reflect 包下的两个类 Proxy和Invocationhandler类来实现。

  Invocationhandler是一个接口，可以实现该接口定义逻辑横切，通过反射的方法调用目标类的代码，动态地将横切的逻辑和业务代码写在一起。

  ​	缺点 只能为接口创建代理实例。

  

- CGLib动态代理

  通过CGLib继承被代理的类，重写父类的方法，实现AOP面向切面编程。

  ​	

### 事务

事务的传播机制

支持当前事务     不支持当前事务

requierd      requires new

supports      not supported

mandatory 	never 

nested

required  支持当前事务 ，如果当前没有事务，则新建一个事务

​					如果当前存在事务，则加入当前事务，合并成一个事务。

requires new  不支持当前事务，如果当前存在事务，将当前事务挂起，这个方法会独立提交事务，不受调用者的影响，父级异常，他也正常提交。



supports 如果当前存在事务，加入事务，如果当前不存在事务，以非事务方式运行，这个和不写没区别。



not supported的 以非事务方式运行  如果当前存在事务 则把当前事务挂起

mandatory 如果当前存在事务 则加入当前事务 如果当前不存在事务 抛出异常

never 以非事务方式运行 如果当前存在事务 则抛出异常 ，父级方法必须无事务

nested  如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交

如果当前没有事务，则新建事务+如果它异常，父级可以捕获它的异常而不进行回滚，正常提交+但如果父级异常，它必然回滚，这就是和+REQUIRES_NEW+的区别

### Spring Mybatis

q1 # 和$的区别？

​	\#{} 有效的防止sql注入

  \#{} 传入的数据当成一个字符串 ，会加上"" 

​	类似于预编译的 ？占位符，可以有效防止sql注入。



${} 就是简单的字符串替换 ，不能防止 sql注入，在  表名和 order by 中常常使用，因为这两个不能加引号 